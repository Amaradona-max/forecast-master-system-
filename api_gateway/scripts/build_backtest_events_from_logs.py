#!/usr/bin/env python3
"""Build backtest_events.jsonl by joining prediction_events.jsonl with results.

Inputs:
- prediction_events.jsonl (generated by API when PREDICTION_LOG_ENABLE=1)
- results.jsonl OR results.json (user-provided)
    Each record must contain match_id and actual outcome.

Supported results shapes:
- {"match_id":"...", "outcome":"home_win"}  OR outcome in {"home_win","draw","away_win"}
- {"match_id":"...", "result":"1"} with 1/X/2 mapping
- {"match_id":"...", "home_goals":2, "away_goals":1}  -> outcome derived

Output:
- backtest_events.jsonl suitable for build_similarity_buckets.py (Step 8)

Usage:
  python api_gateway/scripts/build_backtest_events_from_logs.py \
    --pred api_gateway/data/prediction_events.jsonl \
    --results api_gateway/data/match_results.jsonl \
    --out api_gateway/data/backtest_events.jsonl
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any


def iter_jsonl(path: Path):
    if not path.exists():
        return
    for ln in path.read_text(encoding="utf-8", errors="ignore").splitlines():
        ln = ln.strip()
        if not ln:
            continue
        try:
            obj = json.loads(ln)
            if isinstance(obj, dict):
                yield obj
        except Exception:
            continue


def load_results(path: Path) -> dict[str, dict[str, Any]]:
    if not path.exists():
        return {}
    text = path.read_text(encoding="utf-8", errors="ignore").strip()
    if not text:
        return {}
    if text.startswith("["):
        try:
            arr = json.loads(text)
            if isinstance(arr, list):
                return {str(r.get("match_id")): r for r in arr if isinstance(r, dict) and r.get("match_id")}
        except Exception:
            return {}
    if text.startswith("{"):
        try:
            obj = json.loads(text)
            if isinstance(obj, dict) and obj.get("match_id"):
                return {str(obj["match_id"]): obj}
            recs = obj.get("records")
            if isinstance(recs, list):
                return {str(r.get("match_id")): r for r in recs if isinstance(r, dict) and r.get("match_id")}
        except Exception:
            return {}
    return {str(r.get("match_id")): r for r in iter_jsonl(path) if r.get("match_id")}


def norm_outcome(x: Any) -> str | None:
    if x is None:
        return None
    s = str(x).strip().lower()
    if s in {"home_win", "1", "h", "home"}:
        return "home_win"
    if s in {"draw", "x", "d"}:
        return "draw"
    if s in {"away_win", "2", "a", "away"}:
        return "away_win"
    return None


def outcome_from_goals(r: dict[str, Any]) -> str | None:
    hg = r.get("home_goals", r.get("hg"))
    ag = r.get("away_goals", r.get("ag"))
    try:
        hg = int(hg)
        ag = int(ag)
    except Exception:
        return None
    if hg > ag:
        return "home_win"
    if hg < ag:
        return "away_win"
    return "draw"


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--pred", required=True, help="prediction_events.jsonl")
    ap.add_argument("--results", required=True, help="match_results.jsonl or .json")
    ap.add_argument("--out", required=True, help="backtest_events.jsonl output")
    ap.add_argument("--min-tier", default="B", help="keep only tiers >= this (S/A/B/C). default B")
    args = ap.parse_args()

    tier_order = {"S": 3, "A": 2, "B": 1, "C": 0}
    min_t = str(args.min_tier).strip().upper()
    min_rank = tier_order.get(min_t, 0)

    pred_path = Path(args.pred)
    res_path = Path(args.results)
    out_path = Path(args.out)

    results = load_results(res_path)
    if not results:
        print("No results found. Provide match_results.jsonl/.json with match_id + outcome (or goals).")
        return 2

    out_path.parent.mkdir(parents=True, exist_ok=True)
    kept = 0
    joined = 0
    with out_path.open("w", encoding="utf-8") as f:
        for p in iter_jsonl(pred_path):
            mid = str(p.get("match_id") or "").strip()
            if not mid or mid not in results:
                continue
            r = results[mid]
            actual = norm_outcome(r.get("outcome") or r.get("result")) or outcome_from_goals(r)
            if actual is None:
                continue

            tier = str(p.get("tier") or "").upper() if p.get("tier") else ""
            if tier and tier_order.get(tier, -1) < min_rank:
                continue

            probs = p.get("probs") if isinstance(p.get("probs"), dict) else {}
            pick = norm_outcome(p.get("pick"))
            if pick is None:
                p1 = float(probs.get("home_win", 0.0) or 0.0)
                px = float(probs.get("draw", 0.0) or 0.0)
                p2 = float(probs.get("away_win", 0.0) or 0.0)
                pick = "home_win" if (p1 >= px and p1 >= p2) else "draw" if (px >= p1 and px >= p2) else "away_win"

            hit = bool(pick == actual)
            rec = {
                "championship": p.get("championship"),
                "tier": tier or None,
                "chaos_index": p.get("chaos_index"),
                "fragility_level": p.get("fragility_level"),
                "hit": hit,
                "match_id": mid,
            }
            f.write(json.dumps(rec, ensure_ascii=False) + "\n")
            joined += 1
            kept += 1 if hit else 0

    print(f"Joined records: {joined}. Hits: {kept}. Output: {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
